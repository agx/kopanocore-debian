From: =?utf-8?q?Guido_G=C3=BCnther?= <agx@sigxcpu.org>
Date: Thu, 17 Sep 2015 12:46:39 +0200
Subject: Remove archiver related code

so we don't have to ship currently non functional libarchive.
---
 ECtools/Makefile.am              |   2 +-
 ECtools/admin/zarafa-admin.cpp   | 148 +-------------------
 ECtools/zarafa-admin/Makefile.am |   1 -
 spooler/DAgent.cpp               |  42 +-----
 spooler/Makefile.am              |   4 -
 spooler/archive.cpp              | 288 ---------------------------------------
 spooler/mailer.cpp               |  15 +-
 swig/Makefile.am                 |   2 +-
 swig/python/Makefile.am          |  14 +-
 9 files changed, 12 insertions(+), 504 deletions(-)

diff --git a/ECtools/Makefile.am b/ECtools/Makefile.am
index a887d7f..9b47a5b 100644
--- a/ECtools/Makefile.am
+++ b/ECtools/Makefile.am
@@ -28,7 +28,7 @@ zarafa_admin_LDADD = \
 	${top_builddir}/common/libzcp_common_mapi.la \
 	${top_builddir}/common/libzcp_common_util.la \
 	${top_builddir}/common/libzcp_common_ssl.la \
-	libzarafa-archiver.la ${PROG_LIBS} ${SSL_LIBS}
+	${PROG_LIBS} ${SSL_LIBS}
 
 zarafa_archiver_SOURCES = \
 	archiver/main.cpp
diff --git a/ECtools/admin/zarafa-admin.cpp b/ECtools/admin/zarafa-admin.cpp
index f037379..924b488 100644
--- a/ECtools/admin/zarafa-admin.cpp
+++ b/ECtools/admin/zarafa-admin.cpp
@@ -310,10 +310,10 @@ static void print_help(const char *name)
 	ct.AddColumn(0, "--remove-store storeguid"); ct.AddColumn(1, "Delete orphaned store of user that is deleted from external source.");
 	ct.AddColumn(0, "--hook-store storeguid"); ct.AddColumn(1, "Hook orphaned store to a user or copy to a public.");
 	ct.AddColumn(0, "  -u username"); ct.AddColumn(1, "Update user to received orphaned store given in --hook-store.");
-	ct.AddColumn(0, "  --type"); ct.AddColumn(1, "Type of the user to hook. Defaults to 'user', can be 'group' or 'company' for public store. Use 'archive' for archive stores.");
+	ct.AddColumn(0, "  --type"); ct.AddColumn(1, "Type of the user to hook. Defaults to 'user', can be 'group' or 'company' for public store.");
 	ct.AddColumn(0, "  --copyto-public"); ct.AddColumn(1, "Copy the orphan store to the public folder.");
 	ct.AddColumn(0, "--unhook-store username"); ct.AddColumn(1, "Unhook store from user.");
-	ct.AddColumn(0, "  --type"); ct.AddColumn(1, "Type of the user to hook. Defaults to 'user', can be 'group' or 'company' for public store. Use 'archive' for archive stores.");
+	ct.AddColumn(0, "  --type"); ct.AddColumn(1, "Type of the user to hook. Defaults to 'user', can be 'group' or 'company' for public store.");
 	ct.AddColumn(0, ""); ct.AddColumn(1, "Use 'Everyone' as username with type 'group' to unhook the public store, or use the company name and type 'company'.");
 	ct.AddColumn(0, "--force-resync [username [username [...]]]"); ct.AddColumn(1, "Force a resynchronisation of offline profiles for specified users.");
 	ct.AddColumn(0, "--reset-folder-count username"); ct.AddColumn(1, "Reset the counters on all folder in the store.");
@@ -815,11 +815,10 @@ static void adm_oof_status(const SPropValue *const prop)
  * @param[in]	bAutoAccept			Meeting request settings of user
  * @param[in]	bDeclineConflict	Meeting request settings of user
  * @param[in]	bDeclineRecurring	Meeting request settings of user
- * @param[in]	lstArchives			List of attached archives
  */
 static void print_user_settings(IMsgStore *lpStore, const ECUSER *lpECUser,
     bool bAutoAccept, bool bDeclineConflict, bool bDeclineRecur,
-    const ArchiveList &lstArchives, const ECUSERCLIENTUPDATESTATUS *lpECUCUS)
+    const ECUSERCLIENTUPDATESTATUS *lpECUCUS)
 {
 	LPSPropValue lpProps = NULL;
 	SizedSPropTagArray(5, sptaProps) = {5, { PR_LAST_LOGON_TIME, PR_LAST_LOGOFF_TIME, PR_EC_OUTOFOFFICE, PR_EC_OUTOFOFFICE_FROM, PR_EC_OUTOFOFFICE_UNTIL } };
@@ -868,24 +867,6 @@ static void print_user_settings(IMsgStore *lpStore, const ECUSER *lpECUser,
 
 	print_extra_settings(&lpECUser->sPropmap, &lpECUser->sMVPropmap);
 
-	if (!lstArchives.empty()) {
-		cout << "Attached archives:\t" << lstArchives.size() << endl;
-		for (ArchiveList::const_iterator iArchive = lstArchives.begin(); iArchive != lstArchives.end(); ++iArchive) {
-			cout << "\t" << iArchive->FolderName << " in " << iArchive->StoreName << " (" << iArchive->StoreGuid << ")";
-
-			if (iArchive->Rights != ARCHIVE_RIGHTS_ABSENT) {
-				if (iArchive->Rights == ROLE_OWNER)
-					cout << " [Read Write]";
-				else if (iArchive->Rights == ROLE_REVIEWER)
-					cout << " [Read Only]";
-				else
-					cout << " [Modified: " << AclRightsToString(iArchive->Rights) << "]";
-			}
-
-			cout << endl;
-		}
-	}
-
 	if (lpECUCUS && lpECUCUS->ulTrackId > 0) {
 		cout << "Client update Information:" << endl;
 
@@ -907,54 +888,6 @@ static void print_user_settings(IMsgStore *lpStore, const ECUSER *lpECUser,
 	MAPIFreeBuffer(lpProps);
 }
 
-/**
- * Print archive store details on local server
- *
- * @param[in]	lpSession		MAPI session of the internal Zarafa System adminstrator user
- * @param[in]	lpECMsgStore	The IECUnknown PR_EC_OBJECT pointer, used as IECServiceAdmin and IExchangeManageStore interface
- * @param[in]	lpszName		Name to resolve, using type in ulClass
- * @return		MAPI error code
- */
-static HRESULT print_archive_details(LPMAPISESSION lpSession,
-    IECUnknown *lpECMsgStore, const char *lpszName)
-{
-	HRESULT hr = hrSuccess;
-	ECServiceAdminPtr ptrServiceAdmin;
-	ULONG cbArchiveId = 0;
-	EntryIdPtr ptrArchiveId;
-	MsgStorePtr ptrArchive;
-	SPropValuePtr ptrArchiveSize;
-
-	hr = lpECMsgStore->QueryInterface(IID_IECServiceAdmin, (void **)&ptrServiceAdmin);
-	if (hr != hrSuccess) {
-		cerr << "Unable to get admin interface." << endl;
-		goto exit;
-	}
-
-	hr = ptrServiceAdmin->GetArchiveStoreEntryID((LPCTSTR)lpszName, NULL, 0, &cbArchiveId, &ptrArchiveId);
-	if (hr != hrSuccess) {
-		cerr << "No archive found for user '" << lpszName << "'." << endl;
-		goto exit;
-	}
-
-	hr = lpSession->OpenMsgStore(0, cbArchiveId, ptrArchiveId, &ptrArchive.iid, 0, &ptrArchive);
-	if (hr != hrSuccess) {
-		cerr << "Unable to open archive." << endl;
-		goto exit;
-	}
-
-	hr = HrGetOneProp(ptrArchive, PR_MESSAGE_SIZE_EXTENDED, &ptrArchiveSize);
-	if (hr != hrSuccess) {
-		cerr << "Unable to get archive store size." << endl;
-		goto exit;
-	}
-
-	cout << "Current store size:\t";
-	cout << stringify_double((double)ptrArchiveSize->Value.li.QuadPart /1024.0 /1024.0, 2, true) << " MiB" << endl;
-
-exit:
-	return hr;
-}
 
 /**
  * Parse a server store entryid to client store entryid.
@@ -1568,21 +1501,6 @@ static HRESULT print_details(LPMAPISESSION lpSession, IECUnknown *lpECMsgStore,
 				hr = hrSuccess; /* Don't make error fatal */
 			}
 
-			hr = ArchiveManage::Create(lpSession, NULL, converter.convert_to<LPTSTR>(lpszName), &ptrArchiveManage);
-			if (hr != hrSuccess) {
-				if (hr != MAPI_E_NOT_FOUND)
-					cerr << "Error while obtaining archive details, " << getMapiCodeString(hr) << endl;
-				hr = hrSuccess; /* Don't make error fatal */
-			}
-
-			if (ptrArchiveManage.get() != NULL) {
-				hr = ptrArchiveManage->ListArchives(&lstArchives, "Root Folder");
-				if (hr != hrSuccess) {
-					cerr << "Error while obtaining archive list, " << getMapiCodeString(hr) << endl;
-					hr = hrSuccess; /* Don't make error fatal */
-				}
-			}
-
 			hr = lpServiceAdmin->GetUserClientUpdateStatus(cbObjectId, lpObjectId, 0, &lpECUCUS);
 			if (hr != hrSuccess) {
 				cerr << "Unable to get auto update status: " <<
@@ -1590,7 +1508,7 @@ static HRESULT print_details(LPMAPISESSION lpSession, IECUnknown *lpECMsgStore,
 					stringify(hr, true) << ")" << endl;
 				hr = hrSuccess;
 			}
-			print_user_settings(lpStore, lpECUser, bAutoAccept, bDeclineConflict, bDeclineRecurring, lstArchives, lpECUCUS);
+			print_user_settings(lpStore, lpECUser, bAutoAccept, bDeclineConflict, bDeclineRecurring, lpECUCUS);
 
 			break;
 	}
@@ -1644,45 +1562,6 @@ static HRESULT print_details(LPMAPISESSION lpSession, IECUnknown *lpECMsgStore,
 		cout << endl;
 	}
 
-	if (lpECUser) {
-		LPMVPROPMAPENTRY lpArchiveServers = FindMVPropmapEntry(lpECUser, PR_EC_ARCHIVE_SERVERS_A);
-		if (lpArchiveServers && lpArchiveServers->cValues) {
-			MsgStorePtr ptrAdminStore;
-
-			hr = lpECMsgStore->QueryInterface(IID_IMsgStore, &ptrAdminStore);
-			if (hr != hrSuccess)
-				goto exit;
-
-			for (int i = 0; i < lpArchiveServers->cValues; ++i) {
-				MsgStorePtr ptrRemoteAdminStore;
-				SPropValuePtr ptrPropValue;
-				IECUnknown *lpECRemoteAdminStore = NULL;
-				HRESULT hrTmp;
-
-				cout << "Archive details on node '" << (LPSTR)lpArchiveServers->lpszValues[i] << "':" << endl;
-				hrTmp = HrGetRemoteAdminStore(lpSession, ptrAdminStore, lpArchiveServers->lpszValues[i], 0, &ptrRemoteAdminStore);
-				if (FAILED(hrTmp)) {
-					cerr << "Unable to access node '" <<
-						(LPSTR)lpArchiveServers->lpszValues[i] <<
-						"': " << GetMAPIErrorMessage(hr) <<
-						"(" << stringify(hrTmp, true) <<
-						")" << endl;
-					continue;
-				}
-
-				hr = HrGetOneProp(ptrRemoteAdminStore, PR_EC_OBJECT, &ptrPropValue);
-				if (hr != hrSuccess || !ptrPropValue || !ptrPropValue->Value.lpszA) {
-					cerr << "Admin object not found." << endl;
-					goto exit;
-				}
-
-				lpECRemoteAdminStore = reinterpret_cast<IECUnknown *>(ptrPropValue->Value.lpszA);
-				print_archive_details(lpSession, lpECRemoteAdminStore, lpszName);
-				cout << endl;
-			}
-		}
-	}
-
 exit:
 	MAPIFreeBuffer(lpECUser);
 	MAPIFreeBuffer(lpECGroup);
@@ -3257,16 +3136,13 @@ int main(int argc, char* argv[])
 				ulClass = DISTLIST_GROUP;
 			else if (stricmp(detailstype, "company") == 0)
 				ulClass = CONTAINER_COMPANY;
-			else if (stricmp(detailstype, "archive") != 0) {
+			else {
 				hr = MAPI_E_INVALID_TYPE;
 				cerr << "Unknown userobject type \"" << detailstype << "\"" << endl;
 				goto exit;
 			}
 
-			if (detailstype && stricmp(detailstype, "archive") == 0)
-				hr = print_archive_details(lpSession, lpECMsgStore, username);
-			else
-				hr = print_details(lpSession, lpECMsgStore, ulClass, username);
+			hr = print_details(lpSession, lpECMsgStore, ulClass, username);
 			if (hr != hrSuccess)
 				goto exit;
 			break;
@@ -3473,9 +3349,6 @@ int main(int argc, char* argv[])
 				if (strcmp(detailstype, "user") == 0) {
 					ulStoreType = ECSTORE_TYPE_PRIVATE;
 					hr = lpServiceAdmin->ResolveUserName((LPTSTR)username, 0, &cbUserId, &lpUserId);
-				} else if (strcmp(detailstype, "archive") == 0) {
-					ulStoreType = ECSTORE_TYPE_ARCHIVE;
-					hr = lpServiceAdmin->ResolveUserName((LPTSTR)username, 0, &cbUserId, &lpUserId);
 				} else if (strcmp(detailstype, "group") == 0) {
 					ulStoreType = ECSTORE_TYPE_PUBLIC;
 					hr = lpServiceAdmin->ResolveGroupName((LPTSTR)username, 0, &cbUserId, &lpUserId);
@@ -3542,9 +3415,6 @@ int main(int argc, char* argv[])
 						if (strcmp(detailstype, "user") == 0) {
 							ulStoreType = ECSTORE_TYPE_PRIVATE;
 							hr = lpServiceAdmin->ResolveUserName((LPTSTR)username, 0, &cbUserId, &lpUserId);
-						} else if (strcmp(detailstype, "archive") == 0) {
-							ulStoreType = ECSTORE_TYPE_ARCHIVE;
-							hr = lpServiceAdmin->ResolveUserName((LPTSTR)username, 0, &cbUserId, &lpUserId);
 						} else if (strcmp(detailstype, "group") == 0) {
 							ulStoreType = ECSTORE_TYPE_PUBLIC;
 							hr = lpServiceAdmin->ResolveGroupName((LPTSTR)username, 0, &cbUserId, &lpUserId);
@@ -3563,11 +3433,7 @@ int main(int argc, char* argv[])
 
 						if (ulStoreType != ECSTORE_TYPE_PUBLIC) {
 							if (ulStoreType == ECSTORE_TYPE_ARCHIVE) {
-								hr = lpServiceAdmin->GetArchiveStoreEntryID((LPTSTR)username, NULL, 0, &cbStoreId, &lpStoreId);
-								if (hr != hrSuccess) {
-									cout << "Unable to unhook store, unable to retrieve store entryid, " << getMapiCodeString(hr, "entryid") << endl;
-									goto exit;
-								}
+								cout << "Unable to unhook store, archives not supported, " << getMapiCodeString(hr, "entryid") << endl;
 							} else {
 								hr = lpMsgStore->QueryInterface(IID_IExchangeManageStore, (LPVOID*)&lpIEMS);
 								if (hr != hrSuccess)
diff --git a/ECtools/zarafa-admin/Makefile.am b/ECtools/zarafa-admin/Makefile.am
index c1fd02b..fa3b7fd 100644
--- a/ECtools/zarafa-admin/Makefile.am
+++ b/ECtools/zarafa-admin/Makefile.am
@@ -12,7 +12,6 @@ zarafa_admin_LDADD = ${top_builddir}/mapi4linux/src/libzarafa_mapi.la \
 	${top_builddir}/common/libzcp_common_mapi.la \
 	${top_builddir}/common/libzcp_common_util.la \
 	${top_builddir}/common/libzcp_common_ssl.la \
-	${top_builddir}/ECtools/zarafa-archiver/libzarafa-archiver.la \
 	$(PROG_LIBS) $(SSL_LIBS)
 
 zarafa_admin_SOURCES = zarafa-admin.cpp
diff --git a/spooler/DAgent.cpp b/spooler/DAgent.cpp
index 5c8842a..f3a6210 100644
--- a/spooler/DAgent.cpp
+++ b/spooler/DAgent.cpp
@@ -2325,19 +2325,6 @@ static HRESULT HrCopyMessageForDelivery(IMessage *lpOrigMessage,
 	if (bFallbackDelivery)
 		lpMessage->DeleteProps((LPSPropTagArray)&sptaFallback, 0);
 		
-	// Make sure the message is not attached to an archive
-	hr = za::helpers::MAPIPropHelper::Create(MAPIPropPtr(lpMessage, true), &ptrArchiveHelper);
-	if (hr != hrSuccess) {
-		g_lpLogger->Log(EC_LOGLEVEL_ERROR, "HrCopyMessageForDelivery(): za::helpers::MAPIPropHelper::Create failed %x", hr);
-		goto exit;
-	}
-	
-	hr = ptrArchiveHelper->DetachFromArchives();
-	if (hr != hrSuccess) {
-		g_lpLogger->Log(EC_LOGLEVEL_ERROR, "HrCopyMessageForDelivery(): DetachFromArchives failed %x", hr);
-		goto exit;
-	}
-
 	if (lpRecip->bHasIMAP)
 		hr = Util::HrCopyIMAPData(lpOrigMessage, lpMessage);
 	else
@@ -2731,34 +2718,7 @@ static HRESULT ProcessDeliveryToRecipient(PyMapiPlugin *lppyMapiPlugin,
 		// TODO do something with ulResult
 
 		if (parseBool(g_lpConfig->GetSetting("archive_on_delivery"))) {
-			MAPISessionPtr ptrAdminSession;
-			ArchivePtr ptrArchive;
-
-			if (bIsAdmin)
-				hr = lpSession->QueryInterface(ptrAdminSession.iid, &ptrAdminSession);
-			else {
-				const char *server = g_lpConfig->GetSetting("server_socket");
-				server = GetServerUnixSocket(server); // let environment override if present
-
-				hr = HrOpenECAdminSession(g_lpLogger, &ptrAdminSession, "spooler/dagent:system", PROJECT_SVN_REV_STR, server, EC_PROFILE_FLAGS_NO_NOTIFICATIONS, g_lpConfig->GetSetting("sslkey_file", "", NULL), g_lpConfig->GetSetting("sslkey_pass", "", NULL));
-			}
-			if (hr != hrSuccess) {
-				g_lpLogger->Log(EC_LOGLEVEL_ERROR, "Unable to open admin session for archive access: 0x%08X", hr);
-				goto exit;
-			}
-
-			hr = Archive::Create(ptrAdminSession, g_lpLogger, &ptrArchive);
-			if (hr != hrSuccess) {
-				g_lpLogger->Log(EC_LOGLEVEL_ERROR, "Unable to instantiate archive object: 0x%08X", hr);
-				goto exit;
-			}
-
-			hr = ptrArchive->HrArchiveMessageForDelivery(lpDeliveryMessage);
-			if (hr != hrSuccess) {
-				g_lpLogger->Log(EC_LOGLEVEL_ERROR, "Unable to archive message: 0x%08X", hr);
-				Util::HrDeleteMessage(lpSession, lpDeliveryMessage);
-				goto exit;
-			}
+			g_lpLogger->Log(EC_LOGLEVEL_ERROR, "Archiving for delivery not implementd");
 		}
 
 		if (lpArgs->bNewmailNotify) {
diff --git a/spooler/Makefile.am b/spooler/Makefile.am
index aaa9d85..8ea9f45 100644
--- a/spooler/Makefile.am
+++ b/spooler/Makefile.am
@@ -18,8 +18,6 @@ zarafa_dagent_LDADD = ${top_builddir}/inetmapi/libinetmapi.la \
 	${top_builddir}/common/libzcp_common_mapi.la \
 	${top_builddir}/common/libzcp_common_util.la \
 	${top_builddir}/common/libzcp_common_ssl.la \
-	${top_builddir}/ECtools/libzarafa-archiver.la \
-	${top_builddir}/ECtools/libzarafa-archiver-core.la \
 	$(PROG_LIBS) $(SSL_LIBS) $(PYTHON_LIBS) $(XML2_LIBS) ${icu_uc_LIBS}
 
 zarafa_spooler_LDADD = ${top_builddir}/inetmapi/libinetmapi.la \
@@ -27,8 +25,6 @@ zarafa_spooler_LDADD = ${top_builddir}/inetmapi/libinetmapi.la \
 	${top_builddir}/common/libzcp_common_mapi.la \
 	${top_builddir}/common/libzcp_common_util.la \
 	${top_builddir}/common/libzcp_common_ssl.la \
-	${top_builddir}/ECtools/libzarafa-archiver.la \
-	${top_builddir}/ECtools/libzarafa-archiver-core.la \
 	$(PROG_LIBS) $(PYTHON_LIBS) $(XML2_LIBS)
 
 zarafa_dagent_SOURCES = \
diff --git a/spooler/archive.cpp b/spooler/archive.cpp
index 3e9d10d..a1dd917 100644
--- a/spooler/archive.cpp
+++ b/spooler/archive.cpp
@@ -90,294 +90,6 @@ Archive::~Archive()
 	m_lpLogger->Release();
 }
 
-HRESULT Archive::HrArchiveMessageForDelivery(IMessage *lpMessage)
-{
-	HRESULT hr = hrSuccess;
-	ULONG cMsgProps;
-	SPropArrayPtr ptrMsgProps;
-	MsgStorePtr ptrStore;
-	ULONG ulType;
-	MAPIFolderPtr ptrFolder;
-	StoreHelperPtr ptrStoreHelper;
-	SObjectEntry refMsgEntry;
-	ObjectEntryList lstArchives;
-	ObjectEntryList::const_iterator iArchive;
-	ArchiverSessionPtr ptrSession;
-	InstanceIdMapperPtr ptrMapper;
-	HelperPtr ptrHelper;
-	list<pair<MessagePtr,PostSaveActionPtr> > lstArchivedMessages;
-	std::list<std::pair<MessagePtr, PostSaveActionPtr> >::const_iterator iArchivedMessage;
-	ArchiveResult result;
-	ObjectEntryList lstReferences;
-	MAPIPropHelperPtr ptrMsgHelper;
-
-	SizedSPropTagArray(3, sptaMessageProps) = {3, {PR_ENTRYID, PR_STORE_ENTRYID, PR_PARENT_ENTRYID}};
-	enum {IDX_ENTRYID, IDX_STORE_ENTRYID, IDX_PARENT_ENTRYID};
-
-	if (lpMessage == NULL) {
-		hr = MAPI_E_INVALID_PARAMETER;
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForDelivery(): invalid parameter");
-		goto exit;
-	}
-
-	hr = lpMessage->GetProps((LPSPropTagArray)&sptaMessageProps, 0, &cMsgProps, &ptrMsgProps);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForDelivery(): GetProps failed %x", hr);
-		goto exit;
-	}
-
-	refMsgEntry.sStoreEntryId.assign(ptrMsgProps[IDX_STORE_ENTRYID].Value.bin);
-	refMsgEntry.sItemEntryId.assign(ptrMsgProps[IDX_ENTRYID].Value.bin);
-
-	hr = m_ptrSession->OpenMsgStore(0, ptrMsgProps[IDX_STORE_ENTRYID].Value.bin.cb, (LPENTRYID)ptrMsgProps[IDX_STORE_ENTRYID].Value.bin.lpb, &ptrStore.iid, MDB_WRITE, &ptrStore);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForDelivery(): OpenMsgStore failed %x", hr);
-		goto exit;
-	}
-
-	hr = StoreHelper::Create(ptrStore, &ptrStoreHelper);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForDelivery(): StoreHelper::Create failed %x", hr);
-		goto exit;
-	}
-
-	hr = ptrStoreHelper->GetArchiveList(&lstArchives);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForDelivery(): StoreHelper::GetArchiveList failed %x", hr);
-		goto exit;
-	}
-
-	if (lstArchives.empty()) {
-		m_lpLogger->Log(EC_LOGLEVEL_DEBUG, "No archives attached to store");
-		goto exit;
-	}
-
-	hr = ptrStore->OpenEntry(ptrMsgProps[IDX_PARENT_ENTRYID].Value.bin.cb, (LPENTRYID)ptrMsgProps[IDX_PARENT_ENTRYID].Value.bin.lpb, &ptrFolder.iid, MAPI_MODIFY, &ulType, &ptrFolder);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForDelivery(): StoreHelper::OpenEntry failed %x", hr);
-		goto exit;
-	}
-
-	hr = ArchiverSession::Create(m_ptrSession, m_lpLogger, &ptrSession);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForDelivery(): ArchiverSession::Create failed %x", hr);
-		goto exit;
-	}
-
-	/**
-	 * @todo: Create an archiver config object globally in the calling application to
-	 *        avoid the creation of the configuration for each message to be archived.
-	 */
-	hr = InstanceIdMapper::Create(m_lpLogger, NULL, &ptrMapper);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForDelivery(): InstanceIdMapper::Create failed %x", hr);
-		goto exit;
-	}
-
-	// First create all (mostly one) the archive messages without saving them.
-	ptrHelper.reset(new Copier::Helper(ptrSession, m_lpLogger, ptrMapper, NULL, ptrFolder));
-	for (iArchive = lstArchives.begin(); iArchive != lstArchives.end(); ++iArchive) {
-		MessagePtr ptrArchivedMsg;
-		PostSaveActionPtr ptrPSAction;
-
-		hr = ptrHelper->CreateArchivedMessage(lpMessage, *iArchive, refMsgEntry, &ptrArchivedMsg, &ptrPSAction);
-		if (hr != hrSuccess) {
-			m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForDelivery(): CreateArchivedMessage failed %x", hr);
-			goto exit;
-		}
-
-		lstArchivedMessages.push_back(make_pair(ptrArchivedMsg, ptrPSAction));
-	}
-
-	// Now save the messages one by one. On failure all saved messages need to be deleted.
-	for (iArchivedMessage = lstArchivedMessages.begin(); iArchivedMessage != lstArchivedMessages.end(); ++iArchivedMessage) {
-		ULONG cArchivedMsgProps;
-		SPropArrayPtr ptrArchivedMsgProps;
-		SObjectEntry refArchiveEntry;
-
-		hr = iArchivedMessage->first->GetProps((LPSPropTagArray)&sptaMessageProps, 0, &cArchivedMsgProps, &ptrArchivedMsgProps);
-		if (hr != hrSuccess) {
-			m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForDelivery(): ArchivedMessage GetProps failed %x", hr);
-			goto exit;
-		}
-
-		refArchiveEntry.sItemEntryId.assign(ptrArchivedMsgProps[IDX_ENTRYID].Value.bin);
-		refArchiveEntry.sStoreEntryId.assign(ptrArchivedMsgProps[IDX_STORE_ENTRYID].Value.bin);
-		lstReferences.push_back(refArchiveEntry);
-
-		hr = iArchivedMessage->first->SaveChanges(KEEP_OPEN_READWRITE);
-		if (hr != hrSuccess) {
-			m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForDelivery(): ArchivedMessage SaveChanges failed %x", hr);
-			goto exit;
-		}
-
-		if (iArchivedMessage->second) {
-			HRESULT hrTmp = iArchivedMessage->second->Execute();
-			if (hrTmp != hrSuccess)
-				m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Failed to execute post save action. hr=0x%08x", hrTmp);
-		}
-
-		result.AddMessage(iArchivedMessage->first);
-	}
-
-	// Now add the references to the original message.
-	lstReferences.sort();
-	lstReferences.unique();
-
-	hr = MAPIPropHelper::Create(MAPIPropPtr(lpMessage, true), &ptrMsgHelper);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForDelivery(): failed creating reference to original message %x", hr);
-		goto exit;
-	}
-
-	hr = ptrMsgHelper->SetArchiveList(lstReferences, true);
-
-exit:
-	// On error delete all saved archives
-	if (FAILED(hr))
-		result.Undo(m_ptrSession);
-
-	return hr;
-}
-
-
-HRESULT Archive::HrArchiveMessageForSending(IMessage *lpMessage, ArchiveResult *lpResult)
-{
-	HRESULT hr = hrSuccess;
-	ULONG cMsgProps;
-	SPropArrayPtr ptrMsgProps;
-	MsgStorePtr ptrStore;
-	StoreHelperPtr ptrStoreHelper;
-	ObjectEntryList lstArchives;
-	ObjectEntryList::const_iterator iArchive;
-	ArchiverSessionPtr ptrSession;
-	InstanceIdMapperPtr ptrMapper;
-	HelperPtr ptrHelper;
-	list<pair<MessagePtr,PostSaveActionPtr> > lstArchivedMessages;
-	std::list<std::pair<MessagePtr, PostSaveActionPtr> >::const_iterator iArchivedMessage;
-	ArchiveResult result;
-
-	SizedSPropTagArray(2, sptaMessageProps) = {1, {PR_STORE_ENTRYID}};
-	enum {IDX_STORE_ENTRYID};
-
-	if (lpMessage == NULL) {
-		hr = MAPI_E_INVALID_PARAMETER;
-		goto exit;
-	}
-
-	hr = lpMessage->GetProps((LPSPropTagArray)&sptaMessageProps, 0, &cMsgProps, &ptrMsgProps);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForSending(): GetProps failed %x", hr);
-		goto exit;
-	}
-
-	hr = m_ptrSession->OpenMsgStore(0, ptrMsgProps[IDX_STORE_ENTRYID].Value.bin.cb, (LPENTRYID)ptrMsgProps[IDX_STORE_ENTRYID].Value.bin.lpb, &ptrStore.iid, 0, &ptrStore);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForSending(): OpenMsgStore failed %x", hr);
-		goto exit;
-	}
-
-	hr = StoreHelper::Create(ptrStore, &ptrStoreHelper);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForSending(): StoreHelper::Create failed %x", hr);
-		goto exit;
-	}
-
-	hr = ptrStoreHelper->GetArchiveList(&lstArchives);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_ERROR, "Unable to obtain list of attached archives. hr=0x%08x", hr);
-		SetErrorMessage(hr, _("Unable to obtain list of attached archives."));
-		goto exit;
-	}
-
-	if (lstArchives.empty()) {
-		m_lpLogger->Log(EC_LOGLEVEL_DEBUG, "No archives attached to store");
-		goto exit;
-	}
-
-	hr = ArchiverSession::Create(m_ptrSession, m_lpLogger, &ptrSession);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForSending(): ArchiverSession::Create failed %x", hr);
-		goto exit;
-	}
-
-	/**
-	 * @todo: Create an archiver config object globally in the calling application to
-	 *        avoid the creation of the configuration for each message to be archived.
-	 */
-	hr = InstanceIdMapper::Create(m_lpLogger, NULL, &ptrMapper);
-	if (hr != hrSuccess) {
-		m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Archive::HrArchiveMessageForSending(): InstanceIdMapper::Create failed %x", hr);
-		goto exit;
-	}
-
-	// First create all (mostly one) the archive messages without saving them.
-	ptrHelper.reset(new Copier::Helper(ptrSession, m_lpLogger, ptrMapper, NULL, MAPIFolderPtr()));	// We pass an empty MAPIFolderPtr here!
-	for (iArchive = lstArchives.begin(); iArchive != lstArchives.end(); ++iArchive) {
-		ArchiveHelperPtr ptrArchiveHelper;
-		MAPIFolderPtr ptrArchiveFolder;
-		MessagePtr ptrArchivedMsg;
-		PostSaveActionPtr ptrPSAction;
-
-		hr = ArchiveHelper::Create(ptrSession, *iArchive, m_lpLogger, &ptrArchiveHelper);
-		if (hr != hrSuccess) {
-			SetErrorMessage(hr, _("Unable to open archive."));
-			goto exit;
-		}
-
-		hr = ptrArchiveHelper->GetOutgoingFolder(&ptrArchiveFolder);
-		if (hr != hrSuccess) {
-			m_lpLogger->Log(EC_LOGLEVEL_ERROR, "Failed to get outgoing archive folder. hr=0x%08x", hr);
-			SetErrorMessage(hr, _("Unable to get outgoing archive folder."));
-			goto exit;
-		}
-
-		hr = ptrArchiveFolder->CreateMessage(&ptrArchivedMsg.iid, 0, &ptrArchivedMsg);
-		if (hr != hrSuccess) {
-			m_lpLogger->Log(EC_LOGLEVEL_ERROR, "Failed to create message in outgoing archive folder. hr=0x%08x", hr);
-			SetErrorMessage(hr, _("Unable to create archive message in outgoing archive folder."));
-			goto exit;
-		}
-
-		hr = ptrHelper->ArchiveMessage(lpMessage, NULL, ptrArchivedMsg, &ptrPSAction);
-		if (hr != hrSuccess) {
-			SetErrorMessage(hr, _("Unable to copy message data."));
-			goto exit;
-		}
-
-		m_lpLogger->Log(EC_LOGLEVEL_INFO, "Stored message in archive");
-		lstArchivedMessages.push_back(make_pair(ptrArchivedMsg, ptrPSAction));
-	}
-
-	// Now save the messages one by one. On failure all saved messages need to be deleted.
-	for (iArchivedMessage = lstArchivedMessages.begin(); iArchivedMessage != lstArchivedMessages.end(); ++iArchivedMessage) {
-		hr = iArchivedMessage->first->SaveChanges(KEEP_OPEN_READONLY);
-		if (hr != hrSuccess) {
-			m_lpLogger->Log(EC_LOGLEVEL_ERROR, "Failed to save message in archive. hr=0x%08x", hr);
-			SetErrorMessage(hr, _("Unable to save archived message."));
-			goto exit;
-		}
-
-		if (iArchivedMessage->second) {
-			HRESULT hrTmp = iArchivedMessage->second->Execute();
-			if (hrTmp != hrSuccess)
-				m_lpLogger->Log(EC_LOGLEVEL_WARNING, "Failed to execute post save action. hr=0x%08x", hrTmp);
-		}
-
-		result.AddMessage(iArchivedMessage->first);
-	}
-
-	if (lpResult)
-		std::swap(result, *lpResult);
-
-exit:
-	// On error delete all saved archives
-	if (FAILED(hr))
-		result.Undo(m_ptrSession);
-
-	return hr;
-}
-
 void Archive::SetErrorMessage(HRESULT hr, LPCTSTR lpszMessage)
 {
 	tostringstream	oss;
diff --git a/spooler/mailer.cpp b/spooler/mailer.cpp
index 2043c6a..845defb 100644
--- a/spooler/mailer.cpp
+++ b/spooler/mailer.cpp
@@ -2589,20 +2589,7 @@ static HRESULT ProcessMessage(IMAPISession *lpAdminSession,
 
 	// Archive the message
 	if (parseBool(g_lpConfig->GetSetting("archive_on_send"))) {
-		ArchivePtr ptrArchive;
-		
-		hr = Archive::Create(lpAdminSession, g_lpLogger, &ptrArchive);
-		if (hr != hrSuccess) {
-			g_lpLogger->Log(EC_LOGLEVEL_ERROR, "Unable to instantiate archive object: 0x%08X", hr);
-			goto exit;
-		}
-		
-		hr = ptrArchive->HrArchiveMessageForSending(lpMessage, &archiveResult);
-		if (hr != hrSuccess) {
-			if (ptrArchive->HaveErrorMessage())
-				lpMailer->setError(ptrArchive->GetErrorMessage());
-			goto exit;
-		}
+		g_lpLogger->Log(EC_LOGLEVEL_ERROR, "Archive for sending not supported");
 	}
 
 
diff --git a/swig/Makefile.am b/swig/Makefile.am
index 6ab7de2..fc30333 100644
--- a/swig/Makefile.am
+++ b/swig/Makefile.am
@@ -10,7 +10,7 @@ EXTRA_DIST = edkmdb.i mapi.i mapiutil.i mapidefs.i mapicode.i mapix.i	\
 	mapinotifsink.i typemap.i helpers.i IECExportChanges.i				\
 	IECMultiStoreTable.i IECServiceAdmin.i IECSpooler.i					\
 	IECTestProtocol.i IECLicense.i inetmapi.i icalmapi.i				\
-	swig_iunknown.h ecdefs.i libcommon.i archiver.i licenseclient.i		\
+	swig_iunknown.h ecdefs.i libcommon.i licenseclient.i		\
 	libfreebusy.i zarafasync.i ECLogger.i RecurrenceState.i				\
 	RecurrenceState.swig.h
 
diff --git a/swig/python/Makefile.am b/swig/python/Makefile.am
index bceb1c9..d9d0624 100644
--- a/swig/python/Makefile.am
+++ b/swig/python/Makefile.am
@@ -9,7 +9,7 @@ lib_LTLIBRARIES = libzcp_pyconv.la libzcp_pydirector.la
 pyexec_LTLIBRARIES = _MAPICore.la _inetmapi.la _icalmapi.la _licenseclient.la
 noinst_LTLIBRARIES = _libcommon.la _libfreebusy.la _RecurrenceState.la
 noinst_DATA = libzcp_pyconv.ldd _MAPICore.ldd _inetmapi.ldd _icalmapi.ldd \
-	_libcommon.ldd _archiver.ldd _libfreebusy.ldd _RecurrenceState.ldd \
+	_libcommon.ldd _libfreebusy.ldd _RecurrenceState.ldd \
 	_licenseclient.ldd
 
 # disable warnings since code is mostly generated
@@ -56,13 +56,6 @@ _icalmapi_la_LIBADD = libzcp_pyconv.la \
 	${top_builddir}/libfreebusy/libfreebusy.la \
 	$(ICAL_LIBS) $(PROG_LIBS) $(PYTHON_LIBS)
 
-_archiver_la_CPPFLAGS = ${AM_CPPFLAGS} -I${top_srcdir}/ECtools/archiver
-_archiver_la_LDFLAGS = ${AM_LDFLAGS} -module -avoid-version -rpath '$(libdir)'
-_archiver_la_LIBADD = \
-	${top_builddir}/ECtools/libzarafa-archiver.la \
-	${top_builddir}/ECtools/libzarafa-archiver-core.la \
-	$(PROG_LIBS) $(PYTHON_LIBS)
-
 _licenseclient_la_CPPFLAGS = ${AM_CPPFLAGS} -I${top_srcdir}/provider/common -I${top_builddir}/provider/soap -I${top_srcdir}/provider/soap ${GSOAP_CFLAGS}
 _licenseclient_la_LDFLAGS = ${AM_LDFLAGS} -module -avoid-version
 _licenseclient_la_LIBADD = ${top_builddir}/provider/common/libzarafacommon.la \
@@ -102,7 +95,6 @@ BUILT_SOURCES = mapi_wrap.cxx \
 				mapi_wrap.h \
 				inetmapi_wrap.cxx \
 				icalmapi_wrap.cxx \
-				archiver_wrap.cxx \
 				libcommon_wrap.cxx \
 				licenseclient_wrap.cxx \
 				libfreebusy_wrap.cxx \
@@ -133,7 +125,6 @@ RecurrenceState.py: $(BUILT_SOURCES)
 _MAPICore_la_SOURCES = mapi_wrap.cxx mapi_wrap.h scl.h
 _inetmapi_la_SOURCES = inetmapi_wrap.cxx
 _icalmapi_la_SOURCES = icalmapi_wrap.cxx
-_archiver_la_SOURCES = archiver_wrap.cxx archiver_conv.h archiver_conv.cpp
 _libcommon_la_SOURCES = libcommon_wrap.cxx
 _RecurrenceState_la_SOURCES = RecurrenceState_wrap.cxx
 _licenseclient_la_SOURCES = licenseclient_wrap.cxx licenseclient_conv.cpp licenseclient_conv.h
@@ -157,9 +148,6 @@ inetmapi_wrap.cxx: ../inetmapi.i ../include/zarafa/typemap.i ../inetmapi.i inclu
 icalmapi_wrap.cxx: ../icalmapi.i ../include/zarafa/typemap.i include/zarafa/typemap_python.i helpers_python.i ../../libicalmapi/icalmapi.h
 	${SWIG_EXEC} -I${top_srcdir}/libicalmapi -I${top_srcdir}/libfreebusy -I${top_srcdir/swig} ${SWIG_CXXFLAGS} -o $@ $<
 
-archiver_wrap.cxx: ../archiver.i archiver_python.i
-	${SWIG_EXEC} -I${top_srcdir}/ECtools/archiver ${SWIG_CXXFLAGS} -o $@ $<
-
 libcommon_wrap.cxx: ../libcommon.i
 	${SWIG_EXEC} -I${top_srcdir}/common -I${top_srcdir}/m4lcommon -I${top_srcdir/swig} ${SWIG_CXXFLAGS} -o $@ $<
 
