/*
 * Copyright 2005 - 2015  Zarafa B.V. and its licensors
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation with the following
 * additional terms according to sec. 7:
 * 
 * "Zarafa" is a registered trademark of Zarafa B.V.
 * The licensing of the Program under the AGPL does not imply a trademark 
 * license. Therefore any rights, title and interest in our trademarks 
 * remain entirely with us.
 * 
 * Our trademark policy, <http://www.zarafa.com/zarafa-trademark-policy>,
 * allows you to use our trademarks in connection with Propagation and 
 * certain other acts regarding the Program. In any case, if you propagate 
 * an unmodified version of the Program you are allowed to use the term 
 * "Zarafa" to indicate that you distribute the Program. Furthermore you 
 * may use our trademarks where it is necessary to indicate the intended 
 * purpose of a product or service provided you use it in accordance with 
 * honest business practices. For questions please contact Zarafa at 
 * trademark@zarafa.com.
 *
 * The interactive user interface of the software displays an attribution 
 * notice containing the term "Zarafa" and/or the logo of Zarafa. 
 * Interactive user interfaces of unmodified and modified versions must 
 * display Appropriate Legal Notices according to sec. 5 of the GNU Affero 
 * General Public License, version 3, when you propagate unmodified or 
 * modified versions of the Program. In accordance with sec. 7 b) of the GNU 
 * Affero General Public License, version 3, these Appropriate Legal Notices 
 * must retain the logo of Zarafa or display the words "Initial Development 
 * by Zarafa" if the display of the logo is not reasonably feasible for
 * technical reasons.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *  
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.7
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_MAPICore_WRAP_H_
#define SWIG_MAPICore_WRAP_H_

#include <map>
#include <string>


class SwigDirector_MAPIAdviseSink : public MAPIAdviseSink, public Swig::Director {

public:
    SwigDirector_MAPIAdviseSink(PyObject *self, ULONG cInterfaces, LPCIID lpInterfaces);
    virtual ULONG OnNotify(ULONG cNotif, LPNOTIFICATION lpNotifications);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class MAPIAdviseSink doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_MAPIProp : public MAPIProp, public Swig::Director {

public:
    SwigDirector_MAPIProp(PyObject *self, ULONG cInterfaces, LPCIID lpInterfaces);
    virtual HRESULT GetLastError(HRESULT hResult, ULONG ulFlags, LPMAPIERROR *OUTPUT);
    virtual HRESULT SaveChanges(ULONG ulFlags);
    virtual HRESULT GetProps(LPSPropTagArray lpPropTagArray, ULONG ulFlags, ULONG *OUTPUTC, LPSPropValue *OUTPUTP);
    virtual HRESULT GetPropList(ULONG ulFlags, LPSPropTagArray *OUTPUT);
    virtual HRESULT OpenProperty(ULONG ulPropTag, LPCIID USE_IID_FOR_OUTPUT, ULONG ulInterfaceOptions, ULONG ulFlags, LPUNKNOWN *OUTPUT_USE_IID);
    virtual HRESULT SetProps(ULONG cValues, LPSPropValue lpProps, LPSPropProblemArray *OUTPUT);
    virtual HRESULT DeleteProps(LPSPropTagArray lpPropTagArray, LPSPropProblemArray *OUTPUT);
    virtual HRESULT CopyTo(ULONG cInterfaces, LPCIID lpInterfaces, LPSPropTagArray lpExcludeProps, ULONG ulUIParam, IMAPIProgress *lpProgress, LPCIID lpInterface, void *lpDestObj, ULONG ulFlags, LPSPropProblemArray *OUTPUT);
    virtual HRESULT CopyProps(LPSPropTagArray lpIncludeProps, ULONG ulUIParam, IMAPIProgress *lpProgress, LPCIID lpInterface, void *lpDestObj, ULONG ulFlags, LPSPropProblemArray *OUTPUT);
    virtual HRESULT GetNamesFromIDs(LPSPropTagArray *lppPropTags, LPGUID lpPropSetGuid, ULONG ulFlags, ULONG *OUTPUTC, LPMAPINAMEID **OUTPUTP);
    virtual HRESULT GetIDsFromNames(ULONG cPropNames, LPMAPINAMEID *lppPropNames, ULONG ulFlags, LPSPropTagArray *OUTPUT);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class MAPIProp doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[11];
#endif

};


class SwigDirector_Message : public Message, public Swig::Director {

public:
    SwigDirector_Message(PyObject *self, ULONG cInterfaces, LPCIID lpInterfaces);
    virtual HRESULT GetLastError(HRESULT hResult, ULONG ulFlags, LPMAPIERROR *OUTPUT);
    virtual HRESULT SaveChanges(ULONG ulFlags);
    virtual HRESULT GetProps(LPSPropTagArray lpPropTagArray, ULONG ulFlags, ULONG *OUTPUTC, LPSPropValue *OUTPUTP);
    virtual HRESULT GetPropList(ULONG ulFlags, LPSPropTagArray *OUTPUT);
    virtual HRESULT OpenProperty(ULONG ulPropTag, LPCIID USE_IID_FOR_OUTPUT, ULONG ulInterfaceOptions, ULONG ulFlags, LPUNKNOWN *OUTPUT_USE_IID);
    virtual HRESULT SetProps(ULONG cValues, LPSPropValue lpProps, LPSPropProblemArray *OUTPUT);
    virtual HRESULT DeleteProps(LPSPropTagArray lpPropTagArray, LPSPropProblemArray *OUTPUT);
    virtual HRESULT CopyTo(ULONG cInterfaces, LPCIID lpInterfaces, LPSPropTagArray lpExcludeProps, ULONG ulUIParam, IMAPIProgress *lpProgress, LPCIID lpInterface, void *lpDestObj, ULONG ulFlags, LPSPropProblemArray *OUTPUT);
    virtual HRESULT CopyProps(LPSPropTagArray lpIncludeProps, ULONG ulUIParam, IMAPIProgress *lpProgress, LPCIID lpInterface, void *lpDestObj, ULONG ulFlags, LPSPropProblemArray *OUTPUT);
    virtual HRESULT GetNamesFromIDs(LPSPropTagArray *lppPropTags, LPGUID lpPropSetGuid, ULONG ulFlags, ULONG *OUTPUTC, LPMAPINAMEID **OUTPUTP);
    virtual HRESULT GetIDsFromNames(ULONG cPropNames, LPMAPINAMEID *lppPropNames, ULONG ulFlags, LPSPropTagArray *OUTPUT);
    virtual HRESULT GetAttachmentTable(ULONG ulFlags, IMAPITable **OUTPUT);
    virtual HRESULT OpenAttach(ULONG ulAttachmentNum, LPCIID lpInterface, ULONG ulFlags, IAttach **OUTPUT);
    virtual HRESULT CreateAttach(LPCIID lpInterface, ULONG ulFlags, ULONG *lpulAttachmentNum, IAttach **OUTPUT);
    virtual HRESULT DeleteAttach(ULONG ulAttachmentNum, ULONG ulUIParam, IMAPIProgress *lpProgress, ULONG ulFlags);
    virtual HRESULT GetRecipientTable(ULONG ulFlags, IMAPITable **OUTPUT);
    virtual HRESULT ModifyRecipients(ULONG ulFlags, LPADRLIST INPUT);
    virtual HRESULT SubmitMessage(ULONG ulFlags);
    virtual HRESULT SetReadFlag(ULONG ulFlags);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Message doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[19];
#endif

};


class SwigDirector_Attach : public Attach, public Swig::Director {

public:
    SwigDirector_Attach(PyObject *self, ULONG cInterfaces, LPCIID lpInterfaces);
    virtual HRESULT GetLastError(HRESULT hResult, ULONG ulFlags, LPMAPIERROR *OUTPUT);
    virtual HRESULT SaveChanges(ULONG ulFlags);
    virtual HRESULT GetProps(LPSPropTagArray lpPropTagArray, ULONG ulFlags, ULONG *OUTPUTC, LPSPropValue *OUTPUTP);
    virtual HRESULT GetPropList(ULONG ulFlags, LPSPropTagArray *OUTPUT);
    virtual HRESULT OpenProperty(ULONG ulPropTag, LPCIID USE_IID_FOR_OUTPUT, ULONG ulInterfaceOptions, ULONG ulFlags, LPUNKNOWN *OUTPUT_USE_IID);
    virtual HRESULT SetProps(ULONG cValues, LPSPropValue lpProps, LPSPropProblemArray *OUTPUT);
    virtual HRESULT DeleteProps(LPSPropTagArray lpPropTagArray, LPSPropProblemArray *OUTPUT);
    virtual HRESULT CopyTo(ULONG cInterfaces, LPCIID lpInterfaces, LPSPropTagArray lpExcludeProps, ULONG ulUIParam, IMAPIProgress *lpProgress, LPCIID lpInterface, void *lpDestObj, ULONG ulFlags, LPSPropProblemArray *OUTPUT);
    virtual HRESULT CopyProps(LPSPropTagArray lpIncludeProps, ULONG ulUIParam, IMAPIProgress *lpProgress, LPCIID lpInterface, void *lpDestObj, ULONG ulFlags, LPSPropProblemArray *OUTPUT);
    virtual HRESULT GetNamesFromIDs(LPSPropTagArray *lppPropTags, LPGUID lpPropSetGuid, ULONG ulFlags, ULONG *OUTPUTC, LPMAPINAMEID **OUTPUTP);
    virtual HRESULT GetIDsFromNames(ULONG cPropNames, LPMAPINAMEID *lppPropNames, ULONG ulFlags, LPSPropTagArray *OUTPUT);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Attach doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[11];
#endif

};


class SwigDirector_MAPITable : public MAPITable, public Swig::Director {

public:
    SwigDirector_MAPITable(PyObject *self, ULONG cInterfaces, LPCIID lpInterfaces);
    virtual HRESULT GetLastError(HRESULT hResult, ULONG ulFlags, LPMAPIERROR *OUTPUT);
    virtual HRESULT Advise(ULONG ulEventMask, IMAPIAdviseSink *lpAdviseSink, ULONG *OUTPUT);
    virtual HRESULT Unadvise(ULONG ulConnection);
    virtual HRESULT GetStatus(ULONG *lpulTableStatus, ULONG *OUTPUT);
    virtual HRESULT SetColumns(LPSPropTagArray lpPropTagArray, ULONG ulFlags);
    virtual HRESULT QueryColumns(ULONG ulFlags, LPSPropTagArray *OUTPUT);
    virtual HRESULT GetRowCount(ULONG ulFlags, ULONG *OUTPUT);
    virtual HRESULT SeekRow(BOOKMARK bkOrigin, LONG lRowCount, LONG *OUTPUT);
    virtual HRESULT SeekRowApprox(ULONG ulNumerator, ULONG ulDenominator);
    virtual HRESULT QueryPosition(ULONG *lpulRow, ULONG *OUTPUT1, ULONG *OUTPUT2);
    virtual HRESULT FindRow(LPSRestriction lpRestriction, BOOKMARK bkOrigin, ULONG ulFlags);
    virtual HRESULT Restrict(LPSRestriction lpRestriction, ULONG ulFlags);
    virtual HRESULT CreateBookmark(BOOKMARK *OUTPUT);
    virtual HRESULT FreeBookmark(BOOKMARK bkPosition);
    virtual HRESULT SortTable(LPSSortOrderSet lpSortCriteria, ULONG ulFlags);
    virtual HRESULT QuerySortOrder(LPSSortOrderSet *OUTPUT);
    virtual HRESULT QueryRows(LONG lRowCount, ULONG ulFlags, LPSRowSet *OUTPUT);
    virtual HRESULT Abort();
    virtual HRESULT ExpandRow(ULONG cbInstanceKey, BYTE *pbInstanceKey, ULONG ulRowCount, ULONG ulFlags, LPSRowSet *OUTPUT, ULONG *OUTPUT2);
    virtual HRESULT CollapseRow(ULONG cbInstanceKey, BYTE *pbInstanceKey, ULONG ulFlags, ULONG *OUTPUT);
    virtual HRESULT WaitForCompletion(ULONG ulFlags, ULONG ulTimeout, ULONG *OUTPUT);
    virtual HRESULT GetCollapseState(ULONG ulFlags, ULONG cbInstanceKey, BYTE *pbInstanceKey, ULONG *lpulOutput, LPBYTE *lpOutput);
    virtual HRESULT SetCollapseState(ULONG ulFlags, ULONG cbCollapseState, BYTE *pbCollapseState, BOOKMARK *OUTPUT);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class MAPITable doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[23];
#endif

};


class SwigDirector_ExchangeImportContentsChanges : public ExchangeImportContentsChanges, public Swig::Director {

public:
    SwigDirector_ExchangeImportContentsChanges(PyObject *self, ULONG cInterfaces, LPCIID lpInterfaces);
    virtual HRESULT GetLastError(HRESULT hResult, ULONG ulFlags, LPMAPIERROR *OUTPUT);
    virtual HRESULT Config(IStream *lpStream, ULONG ulFlags);
    virtual HRESULT UpdateState(IStream *lpStream);
    virtual HRESULT ImportMessageChange(ULONG cValues, LPSPropValue lpProps, ULONG ulFlags, IMessage **lppMessage);
    virtual HRESULT ImportMessageDeletion(ULONG ulFlags, LPENTRYLIST lpSourceEntryList);
    virtual HRESULT ImportPerUserReadStateChange(ULONG cElements, LPREADSTATE lpReadState);
    virtual HRESULT ImportMessageMove(ULONG cbSourceKeySrcFolder, BYTE *pbSourceKeySrcFolder, ULONG cbSourceKeySrcMessage, BYTE *pbSourceKeySrcMessage, ULONG cbPCLMessage, BYTE *pbPCLMessage, ULONG cbSourceKeyDestMessage, BYTE *pbSourceKeyDestMessage, ULONG cbChangeNumDestMessage, BYTE *pbChangeNumDestMessage);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ExchangeImportContentsChanges doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_ExchangeImportHierarchyChanges : public ExchangeImportHierarchyChanges, public Swig::Director {

public:
    SwigDirector_ExchangeImportHierarchyChanges(PyObject *self, ULONG cInterfaces, LPCIID lpInterfaces);
    virtual HRESULT GetLastError(HRESULT hResult, ULONG ulFlags, LPMAPIERROR *OUTPUT);
    virtual HRESULT Config(IStream *lpStream, ULONG ulFlags);
    virtual HRESULT UpdateState(IStream *lpStream);
    virtual HRESULT ImportFolderChange(ULONG cValues, LPSPropValue lpProps);
    virtual HRESULT ImportFolderDeletion(ULONG ulFlags, LPENTRYLIST lpSrcEntryList);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ExchangeImportHierarchyChanges doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_ExchangeExportChanges : public ExchangeExportChanges, public Swig::Director {

public:
    SwigDirector_ExchangeExportChanges(PyObject *self, ULONG cInterfaces, LPCIID lpInterfaces);
    virtual HRESULT GetLastError(HRESULT hResult, ULONG ulFlags, LPMAPIERROR *OUTPUT);
    virtual HRESULT Config(IStream *lpStream, ULONG ulFlags, IUnknown *lpUnk, LPSRestriction lpRestriction, LPSPropTagArray lpIncludeProps, LPSPropTagArray lpExcludeProps, ULONG ulBufferSize);
    virtual HRESULT Synchronize(ULONG *lpulSteps, ULONG *INOUT);
    virtual HRESULT UpdateState(IStream *lpStream);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ExchangeExportChanges doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[4];
#endif

};


class SwigDirector_ECChangeAdviseSink : public ECChangeAdviseSink, public Swig::Director {

public:
    SwigDirector_ECChangeAdviseSink(PyObject *self, ULONG cInterfaces, LPCIID lpInterfaces);
    virtual ULONG OnNotify(ULONG ulFlags, LPENTRYLIST lpEntryList);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ECChangeAdviseSink doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_ECImportContentsChanges : public ECImportContentsChanges, public Swig::Director {

public:
    SwigDirector_ECImportContentsChanges(PyObject *self, ULONG cInterfaces, LPCIID lpInterfaces);
    virtual HRESULT GetLastError(HRESULT hResult, ULONG ulFlags, LPMAPIERROR *OUTPUT);
    virtual HRESULT Config(IStream *lpStream, ULONG ulFlags);
    virtual HRESULT UpdateState(IStream *lpStream);
    virtual HRESULT ImportMessageChange(ULONG cValues, LPSPropValue lpProps, ULONG ulFlags, IMessage **lppMessage);
    virtual HRESULT ImportMessageDeletion(ULONG ulFlags, LPENTRYLIST lpSourceEntryList);
    virtual HRESULT ImportPerUserReadStateChange(ULONG cElements, LPREADSTATE lpReadState);
    virtual HRESULT ImportMessageMove(ULONG cbSourceKeySrcFolder, BYTE *pbSourceKeySrcFolder, ULONG cbSourceKeySrcMessage, BYTE *pbSourceKeySrcMessage, ULONG cbPCLMessage, BYTE *pbPCLMessage, ULONG cbSourceKeyDestMessage, BYTE *pbSourceKeyDestMessage, ULONG cbChangeNumDestMessage, BYTE *pbChangeNumDestMessage);
    virtual HRESULT ConfigForConversionStream(IStream *lpStream, ULONG ulFlags, ULONG cValuesConversion, LPSPropValue lpPropArrayConversion);
    virtual HRESULT ImportMessageChangeAsAStream(ULONG cValues, LPSPropValue lpProps, ULONG ulFlags, IStream **lppStream);
    virtual HRESULT SetMessageInterface(IID const &refiid);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ECImportContentsChanges doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[10];
#endif

};


class SwigDirector_ECImportHierarchyChanges : public ECImportHierarchyChanges, public Swig::Director {

public:
    SwigDirector_ECImportHierarchyChanges(PyObject *self, ULONG cInterfaces, LPCIID lpInterfaces);
    virtual HRESULT GetLastError(HRESULT hResult, ULONG ulFlags, LPMAPIERROR *OUTPUT);
    virtual HRESULT Config(IStream *lpStream, ULONG ulFlags);
    virtual HRESULT UpdateState(IStream *lpStream);
    virtual HRESULT ImportFolderChange(ULONG cValues, LPSPropValue lpProps);
    virtual HRESULT ImportFolderDeletion(ULONG ulFlags, LPENTRYLIST lpSrcEntryList);
    virtual HRESULT ImportFolderChangeEx(ULONG cValues, LPSPropValue lpProps, BOOL fNew);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ECImportHierarchyChanges doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_ECSimpleLogger : public ECSimpleLogger, public Swig::Director {

public:
    SwigDirector_ECSimpleLogger(PyObject *self);
    virtual HRESULT Log(unsigned int loglevel, char const *szMessage);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ECSimpleLogger doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_Stream : public Stream, public Swig::Director {

public:
    SwigDirector_Stream(PyObject *self, ULONG cInterfaces, LPCIID lpInterfaces);
    virtual HRESULT Write(void const *pv, ULONG cb, ULONG *OUTPUT);
    virtual HRESULT Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    virtual HRESULT SetSize(ULARGE_INTEGER libNewSize);
    virtual HRESULT CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    virtual HRESULT Commit(DWORD grfCommitFlags);
    virtual HRESULT Revert();
    virtual HRESULT LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    virtual HRESULT UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    virtual HRESULT Stat(STATSTG *OUTPUT, DWORD grfStatFlag);
    virtual HRESULT Clone(IStream **ppstm);
    virtual HRESULT Read(void *OUTPUT, ULONG cb, ULONG *cbOUTPUT);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* swig_protected_method_name, bool val) const
    { swig_inner[swig_protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Stream doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[11];
#endif

};


#endif
